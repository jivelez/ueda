
## nice colors
cols <- c("#0080ff", "#ff00ff", "darkgreen", "#ff0000", "orange", "#00ff00", "brown")



## get cutoff
measures <- function(tt){
  tp <- tt[1, 1]
  fp <- tt[1, 2]
  fn <- tt[2, 1]
  tn <- tt[2, 2]
  n <- sum(tt)
  c("sensitivity" = tp/(tp + fn),
    "specificity" = tn/(fp + tn),
    "ppv" = tp/(tp + fp),
    "npv" = tn/(tn + fn),
    "fdr" = 1 - tp/(tp + fp),
    "fpr" = 1 - tn/(fp + tn),
    "class_rate" = (tp + tn)/sum(tt),
    "lift" = tp*n / ((tp+fp)*(tp+fn)), 
    "delta" = sqrt((tp/(tp + fn)-1)^2 + (tn/(fp + tn)-1)^2))  
}

## medidas de desempeño cuando se utilizan diferentes puntos de corte
measures2 <- function(tt){
  tp <- tt[1, 1]
  fp <- tt[1, 2]
  fn <- tt[2, 1]
  tn <- tt[2, 2]
  n <- sum(tt)
  c("a" = tp, "b" = fp , "c" = fn , "d" = tn,
    "sensitivity" = tp/(tp + fn),
    "specificity" = tn/(fp + tn),
    "ppv" = tp/(tp + fp),
    "npv" = tn/(tn + fn),
    "fdr" = 1 - tp/(tp + fp),
    "fpr" = 1 - tn/(fp + tn),
    "class_rate" = (tp + tn)/sum(tt),
    "lift" = tp*n / ((tp+fp)*(tp+fn)), 
    "delta" = sqrt((tp/(tp + fn)-1)^2 + (tn/(fp + tn)-1)^2))  
}


#  here we calculate the measures for each cutoff value
bycutoff <- function(fittedmodel, real, cutoff){
  predicted <- predict(fittedmodel, type = 'response')
  k <- length(cutoff)
  res <- matrix(NA, ncol = 9, nrow = k)
  colnames(res) <- c('sensitivity', 'specificity', 'ppv', 'npv', 'fdr', 'fpr', 'class_rate', 'lift', 'delta')
  for(i in 1:k){
    r <- 1*(predicted > cutoff[i])
    m <- factor(r, levels = 1:0)
    tt <- table(m, real)[, 2:1]
    res[i, ] <- measures(tt)
  }
  res	
}

#  here we calculate the measures for each cutoff value
bycutoff2 <- function(fittedmodel, real, cutoff){
  predicted <- predict(fittedmodel, type = 'response')
  k <- length(cutoff)
  res <- matrix(NA, ncol = 13, nrow = k)
  colnames(res) <- c('a', 'b', 'c', 'd', 'sensitivity', 'specificity', 'ppv', 'npv', 'fdr', 'fpr', 'class_rate', 'lift', 'delta')
  for(i in 1:k){
    r <- 1*(predicted > cutoff[i])
    m <- factor(r, levels = 1:0)
    tt <- table(m, real)[, 2:1]
    res[i, ] <- measures2(tt)
  }
  res	
}

# measures for 2x2 contingency tables
measureslog <- function(tt){
  n <- sum(tt)
  a <- tt[1, 1]
  b <- tt[1, 2]
  c <- tt[2, 1]
  d <- tt[2, 2]
  c("sensitivity" = a/(a + c),
    "specificity" = d/(b + d),
    "ppv" = a/(a + b),
    "npv" = d/(c + d),
    "fdr" = 1 - a/(a + b),
    "fpr" = 1 - d/(c + d),
    "class_rate" = (a + d)/n,
    "auc" = roc.from.table(tt, graph = FALSE)$auc)
}


myroc <- function (logistic.model, graph = TRUE, add = FALSE, title = FALSE, 
                   line.col = cols[1], auc.coords = NULL, grid = TRUE, grid.col = "white", 
                   ...) 
{
  if (add) {
    title <- FALSE
  }
  if (length(grep("cbind", names(model.frame(logistic.model)))) > 
      0) {
    firsttable1 <- cbind(logistic.model$fitted.values, model.frame(logistic.model)[, 
                                                                                   1][, 2:1])
    firsttable1 <- firsttable1[order(firsttable1[, 1]), ]
  }
  else {
    if (length(grep("(weights)", names(model.frame(logistic.model)))) > 
        0) {
      firsttable <- xtabs(as.vector(model.frame(logistic.model)[, 
                                                                ncol(model.frame(logistic.model))]) ~ logistic.model$fitted.values + 
                            logistic.model$y)
    }
    else {
      firsttable <- table(logistic.model$fitted.values, 
                          logistic.model$y)
    }
    colnames(firsttable) <- c("Non-diseased", "Diseased")
    rownames(firsttable) <- substr(rownames(firsttable), 
                                   1, 6)
    firsttable1 <- cbind(as.numeric(rownames(firsttable)), 
                         firsttable)
  }
  rownames(firsttable1) <- rep("", nrow(firsttable1))
  colnames(firsttable1)[1] <- "predicted.prob"
  firsttable <- firsttable1[, 2:3]
  secondtable <- firsttable
  for (i in 1:length(secondtable[, 1])) {
    secondtable[i, 1] <- (sum(firsttable[, 1]) - sum(firsttable[(1:i), 
                                                                1]))/sum(firsttable[, 1])
    secondtable[i, 2] <- (sum(firsttable[, 2]) - sum(firsttable[(1:i), 
                                                                2]))/sum(firsttable[, 2])
    rownames(secondtable)[i] <- paste(">", rownames(secondtable)[i])
  }
  secondtable <- rbind((c(1, 1)), secondtable)
  colnames(secondtable) <- c("1-Specificity", "Sensitivity")
  model.des <- deparse(logistic.model$formula)
  auc <- 0
  for (i in 1:(nrow(secondtable) - 1)) {
    auc <- auc + (secondtable[i, 1] - secondtable[(i + 1), 
                                                  1]) * 0.5 * (secondtable[i, 2] + secondtable[(i + 
                                                                                                  1), 2])
  }
  if (graph) {
    if (!add) {
      plot(secondtable[, 1], secondtable[, 2], xlab = "1-Specificity", 
           ylab = "Sensitivity", xlim = (c(0, 1)), ylim = (c(0, 
                                                             1)), asp = 1, col = line.col, type = "l", ...)
      if (title) {
        title(main = model.des, ...)
      }
      lines(x = c(0, 1), y = c(0, 1), lty = 1, col = "gray70")
      auclabel <- paste("Area under the curve =", round(auc,
                                                        3))
      if (!is.null(auc.coords)) {
        text(x = auc.coords[1], y = auc.coords[2], pos = 4, 
             labels = auclabel, ...)
      }
    }
    else {
      lines(secondtable[, 1], secondtable[, 2], col = line.col, 
            ...)
    }
  }
  list(model.description = model.des, auc = auc, predicted.table = firsttable1, 
       diagnostic.table = secondtable)
}


rft <- function (table, graph = TRUE, add = FALSE, title = FALSE, line.col = cols[1], 
                 auc.coords = NULL, grid = TRUE, grid.col = "gray50", ...){
  if (dim(table)[2] != 2) 
    stop("There must be 2 columns")
  if (table[1, 1]/table[1, 2] < table[nrow(table), 1]/table[nrow(table), 
                                                            2]) {
    stop("At higher cut-off point, there should be more non-diseased")
  }
  firsttable <- table
  colnames(firsttable) <- c("Non-diseased", "Diseased")
  if (length(rownames(firsttable)) == 0) {
    rownames(firsttable) <- rep("", times = nrow(firsttable))
  }
  secondtable <- firsttable
  for (i in 1:length(secondtable[, 1])) {
    secondtable[i, 1] <- (sum(firsttable[, 1]) - sum(firsttable[(1:i), 
                                                                1]))/sum(firsttable[, 1])
    secondtable[i, 2] <- (sum(firsttable[, 2]) - sum(firsttable[(1:i), 
                                                                2]))/sum(firsttable[, 2])
    rownames(secondtable)[i] <- paste(">", rownames(secondtable)[i])
  }
  secondtable <- rbind((c(1, 1)), secondtable)
  colnames(secondtable) <- c("1-Specificity", "Sensitivity")
  auc <- 0
  for (i in 1:(nrow(secondtable) - 1)) {
    auc <- auc + (secondtable[i, 1] - secondtable[(i + 1), 
                                                  1]) * 0.5 * (secondtable[i, 2] + secondtable[(i + 
                                                                                                  1), 2])
  }
  if (graph) {
    if (!add) {
      plot(secondtable[, 1], secondtable[, 2], xlab = "1-Specificity", 
           ylab = "Sensitivity", xlim = (c(0, 1)), ylim = (c(0, 
                                                             1)), asp = 1, col = line.col, type = "l", ...)
      if (title) {
        title(main = "ROC curve of the diagnostic table", 
              ...)
      }
      lines(x = c(0, 1), y = c(0, 1), lty = 1, col = "gray70")
      if (grid) {
        #abline(v = 0, lty = 2, col = grid.col)
        #abline(v = 0.2, lty = 2, col = grid.col)
        #abline(v = 0.4, lty = 2, col = grid.col)
        #abline(v = 0.6, lty = 2, col = grid.col)
        #abline(v = 0.8, lty = 2, col = grid.col)
        #abline(v = 1, lty = 2, col = grid.col)
        #abline(h = 0, lty = 2, col = grid.col)
        #abline(h = 0.2, lty = 2, col = grid.col)
        #abline(h = 0.4, lty = 2, col = grid.col)
        #abline(h = 0.6, lty = 2, col = grid.col)
        #abline(h = 0.8, lty = 2, col = grid.col)
        #abline(h = 1, lty = 2, col = grid.col)
      }
      auclabel <- paste("Area under the curve =", round(auc, 
                                                        3))
    }
    else {
      lines(secondtable[, 1], secondtable[, 2], col = line.col, 
            ...)
    }
    if (!is.null(auc.coords)) {
      text(x = auc.coords[1], y = auc.coords[2], pos = 4, 
           labels = auclabel, ...)
    }
  }
  list(auc = auc, original.table = firsttable, diagnostic.table = secondtable)
}

## verificar si el paquete está disponible
if(!require(devtools)) install.packages('devtools')
require(devtools)

## lo mismo pero para el paquete epicalc
if(!require(epicalc)) devtools::install_version("epicalc", version = "2.15.1.0")
require("epicalc")



cat('Esta es una colección de funciones creadas', '\n')
cat('por el profesor Jorge Vélez <https://jivelez.github.io/>', '\n')
cat('para el ajuste y validación de modelos de Clasificación Binaria', '\n', '\n')

cat('En caso de presentar algún inconveniente, por favor', '\n')
cat('repórtelo a jvelezv@uninorte.edu.co', '\n', '\n')
