#  function to autmatically detect outliers using Ueda's method
#  x is the data (a vector)
#  smax is the maximum number of outliers I woud like to detect
findOutliers <- function(x, smax = NULL){
	
	## auxiliary functions
	# The Stirling Formula is used to compute log n!
	stirling <- function(x) 1/2*log(2*pi)+(1/2+x)*log(x)-x

	# Ut function implemented in S programming language and its example:
	# x = data; s = number of outliers
	ut <- function(x, s){
		n <- length(x)
		sigma <- sqrt(sum((x-mean(x))^2)/n) ###### see footnote 4
		ut <- n*log(sigma)+(sqrt(2)*stirling(n))/n*s
		ut
	}

	# here begins the main function	
	sx <- scale(sort(x))
	nmin <- 1
	nmax <- length(sx)

	# find smax based on the number of observations
	if(is.null(smax)) smax <- ifelse(nmax %% 2 == 0, nmax/2 - 1, (nmax - 1)/2)
	else smax <- smax
	
	# search
	s <- smax
	r <- matrix(NA, ncol = s, nrow = s) 
	for(i in 0:(s-1)){
		for(j in 0:(s-1)){
			sini <- seq(nmin, nmin + i)
			sfin <- seq(nmax, nmax - j)
			r[i+1, j+1] <- ut(sx[-c(sini, sfin)], length(sini) + length(sfin))
			}}
	none <- ut(sx, 0)
	toprow <- sapply(0:(s-1), function(s) ut(sx[-seq(nmin, nmin + s)], s + 1))
	leftcol <- sapply(0:(s-1), function(s) ut(sx[-seq(nmax, nmax - s)], s + 1))
	r <- cbind(c(none, toprow), rbind(leftcol, r))
	r2 <- round(r, 3)
	r <- ifelse(r2 == min(r2), paste0(r2, "*"), r2)
	colnames(r) <- c('none', paste0('X', nmax:(nmax - s + 1)))
	rownames(r) <- c('none', paste0('X', 1:(nmin + s - 1)))
	r <- data.frame(r)
	rownames(r2) <- rownames(r)
	colnames(r2) <- colnames(r)

	pos <- as.numeric(which(r2 == min(r2), arr.ind = TRUE))
	srtx <- sort(x)
	rr2 <- NULL
	if(pos[1] == 1 & pos[2] != 1) rr2 <- srtx[-seq(nmax, nmax - pos[2] + 2)]
	if(pos[1] != 1 & pos[2] == 1) rr2 <- srtx[-seq(1, pos[1])]
	if(pos[1] != 1 & pos[2] != 1){
		left <- srtx[-seq(1, pos[1])]
		right <- srtx[-seq(nmax, nmax - pos[2] + 2)]
		if(length(left) == 0 | length(right) == 0) rr2 <- rr2
		else rr2 <- c(left, right)
		}
	
	# output
	list(Ut = r2, label = r, x = srtx, newx = rr2)
}


# --------------------
#   simulated data
# --------------------
# value of smax
set.seed(13)
x <- c(rnorm(25, 300, 10), rnorm(5, 400, 5))   # introduce 5 outliers

# automatic search
search <- sapply(thes <- 1:10, function(s) min(findOutliers(x, smax = s)$Ut))
plot(thes, search, type = 'b', las = 1, ylab = expression(U[t]), xlab = expression(s[max]), pch = 16)
where <- which(search == min(search))[1]
points(thes[where], search[where], pch = 16, col = 2)
where

# data after removing outliers
findOutliers(x, smax = 5)


# --------------------------
#      Rosner's data
# --------------------------
table10 <- c(-0.25, 0.68, 0.94, 1.15, 1.20, 1.26, 1.26, 1.34, 1.38, 1.43, 1.49, 1.49, 1.55, 1.56, 1.58, 1.65, 1.69, 1.70, 1.76, 1.77, 1.81, 1.91, 1.94, 1.96, 1.99, 2.06, 2.09, 2.10, 2.14, 2.15, 2.23, 2.24, 2.26, 2.35, 2.37, 2.40, 2.47, 2.54, 2.62, 2.64, 2.90, 2.92, 2.92, 2.93, 3.21, 3.26, 3.30, 3.59, 3.68, 4.30, 4.64, 5.34, 5.42, 6.01)
table10

# value of smax
findOutliers(table10)  # detect up to length(table10)/2 outliers
findOutliers(table10, smax = 1)
findOutliers(table10, smax = 2)
findOutliers(table10, smax = 3)
findOutliers(table10, smax = 4)
findOutliers(table10, smax = 5)
findOutliers(table10, smax = 6)

# search
search <- sapply(thes <- 4:26, function(s) min(findOutliers(table10, smax = s)$Ut))
plot(thes[1:5], (search)[1:5], type = 'b', las = 1, ylab = expression(U[t]), xlab = expression(s[max]), pch = 16)

# plot
plot(thes, abs(search), type = 'b', las = 1, ylab = expression(U[t]), xlab = expression(s[max]))

# results
findOutliers(table10, smax = 3)
thes[which.min(search)]   # --->  this means smax = 3


# run
res <- findOutliers(table10, smax = 2)
res

findOutliers(table10, smax = 26)

# extrat new data
res$x
res[[3]]   # the same as above

